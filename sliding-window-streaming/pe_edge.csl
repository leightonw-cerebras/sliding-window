const main_color: color = @get_color(8);
const finalize_color: color = @get_color(9);

param num_elems: u16;
param fab_send_color: color;
param fab_recv_color: color;

param MEMCPYD2H_DATA_1: color;       // Color used for D2H memcpy transfer
param MEMCPYH2D_DATA_1: color;       // Color used for H2D memcpy transfer
param memcpyParams: comptime_struct; // Struct containing memcpy params

var send_arr = @zeros([num_elems]i32);
const send_arr_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{num_elems} -> send_arr[i] });

var recv_arr = @zeros([num_elems]i32);
const recv_arr_dsd = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{num_elems} -> recv_arr[i] });

// This module is needed for memcpy infrastructure
const sys_mod = @import_module("<memcpy_multi/memcpy>", @concat_structs(memcpyParams, .{
     .MEMCPYD2H_1=MEMCPYD2H_DATA_1,
     .MEMCPYH2D_1=MEMCPYH2D_DATA_1
}));

// first PE sends to the right; last PE sends to the left
const send_dsd = @get_dsd(fabout_dsd, .{.fabric_color = fab_send_color, .extent = num_elems, .output_queue = 1});
const recv_dsd = @get_dsd(fabin_dsd,  .{.fabric_color = fab_recv_color, .extent = num_elems, .input_queue = @get_input_queue(2)});

const host_out_dsd = @get_dsd(fabout_dsd, .{.fabric_color = MEMCPYD2H_DATA_1, .extent = num_elems});

var num_recv: u16 = 0;

//This task is activated on the first and last PEs.
task startup_task(wlt: i32) void {
  send_arr[num_recv] = wlt;
  num_recv += 1;

  if (num_recv == num_elems) {
    @activate(main_color);
  }
}

task main_task() void {
  @fmovs(send_dsd, send_arr_dsd, .{.async = true});
  @fmovs(recv_dsd, recv_arr_dsd, .{.async = true, .activate = finalize_task});
}

task finalize_task() void {
  @fmovs(host_out_dsd, recv_arr_dsd);
}

comptime {
  @bind_task(startup_task, MEMCPYH2D_DATA_1);
  @bind_task(main_task, main_color);
  @bind_task(finalize_task, finalize_color);

  @block(fab_recv_color);
}
